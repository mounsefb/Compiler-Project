<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DeclClass.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Deca Compiler</a> &gt; <a href="index.source.html" class="el_package">fr.ensimag.deca.tree</a> &gt; <span class="el_source">DeclClass.java</span></div><h1>DeclClass.java</h1><pre class="source lang-java linenums">package fr.ensimag.deca.tree;

import fr.ensimag.deca.DecacCompiler;
import fr.ensimag.deca.context.ClassDefinition;
import fr.ensimag.deca.context.ClassType;
import fr.ensimag.deca.context.ContextualError;
import fr.ensimag.deca.context.EnvironmentExp;
import fr.ensimag.deca.context.EnvironmentExp.DoubleDefException;
import fr.ensimag.deca.context.MethodDefinition;
import fr.ensimag.deca.context.Type;
import fr.ensimag.deca.tools.IndentPrintStream;
import fr.ensimag.deca.tools.SymbolTable.Symbol;
import fr.ensimag.ima.pseudocode.DAddr;
import fr.ensimag.ima.pseudocode.ImmediateInteger;
import fr.ensimag.ima.pseudocode.Label;
import fr.ensimag.ima.pseudocode.LabelOperand;
import fr.ensimag.ima.pseudocode.Register;
import fr.ensimag.ima.pseudocode.RegisterOffset;
import fr.ensimag.ima.pseudocode.instructions.BSR;
import fr.ensimag.ima.pseudocode.instructions.LEA;
import fr.ensimag.ima.pseudocode.instructions.LOAD;
import fr.ensimag.ima.pseudocode.instructions.PUSH;
import fr.ensimag.ima.pseudocode.instructions.RTS;
import fr.ensimag.ima.pseudocode.instructions.STORE;
import fr.ensimag.ima.pseudocode.instructions.SUBSP;

import java.io.PrintStream;
import java.util.Map;
import java.util.TreeMap;
import java.util.stream.Collectors;

import org.apache.commons.lang.Validate;
import org.apache.log4j.Logger;







/**
 * Declaration of a class (&lt;code&gt;class name extends superClass {members}&lt;code&gt;).
 * 
 * @author gl01
 * @date 01/01/2024
 */
public class DeclClass extends AbstractDeclClass {
<span class="fc" id="L48">    private static final Logger LOG = Logger.getLogger(DeclClass.class);</span>
    
    final private AbstractIdentifier name;
    final private AbstractIdentifier superClass;
    final private ListDeclField listField;
    final private ListDeclMethod listMethod;

<span class="fc" id="L55">    public DeclClass(AbstractIdentifier name, AbstractIdentifier superClass, ListDeclField listField, ListDeclMethod listMethod) {</span>
<span class="fc" id="L56">        Validate.notNull(name);</span>
<span class="fc" id="L57">        Validate.notNull(superClass);</span>
<span class="fc" id="L58">        Validate.notNull(listField, &quot;listField null&quot;);</span>
<span class="fc" id="L59">        Validate.notNull(listMethod, &quot;listMethode null&quot;);</span>
<span class="fc" id="L60">        this.name = name;</span>
<span class="fc" id="L61">        this.superClass = superClass;</span>
<span class="fc" id="L62">        this.listField = listField;</span>
<span class="fc" id="L63">        this.listMethod = listMethod;</span>
<span class="fc" id="L64">    }</span>

    /*
     * Getters for the different attributs
     */
    @Override
    public AbstractIdentifier 
    getName(){
<span class="fc" id="L72">        return this.name;</span>
    }
    @Override
    public AbstractIdentifier getSupClass(){
<span class="nc" id="L76">        return this.superClass;</span>
    }
    @Override
    public ListDeclField getListDeclField(){
<span class="fc" id="L80">        return this.listField;</span>
    }
    @Override
    public ListDeclMethod getListDeclMethod(){
<span class="fc" id="L84">        return this.listMethod;</span>
    }


    @Override
    public void decompile(IndentPrintStream s) {
<span class="nc" id="L90">        s.print(&quot;class &quot;);</span>
<span class="nc" id="L91">        this.name.decompile(s);</span>
<span class="nc" id="L92">        s.print(&quot; extends &quot;);</span>
<span class="nc" id="L93">        this.superClass.decompile(s);</span>
<span class="nc" id="L94">        s.println(&quot; {&quot;);</span>
<span class="nc" id="L95">        s.indent();</span>
<span class="nc" id="L96">        this.listField.decompile(s);</span>
<span class="nc" id="L97">        this.listMethod.decompile(s);</span>
<span class="nc" id="L98">        s.unindent();</span>
<span class="nc" id="L99">        s.println(&quot;}&quot;);</span>
<span class="nc" id="L100">    }</span>



    
    @Override
    /**
     * Passe 1 Verification du nom de la classe en la declarant
    */
     protected void verifyClass(DecacCompiler compiler) throws ContextualError {


        //Verification sur la superClasse

        //Je verifie que la superClasse est bien definie dans notre environnement de type
<span class="fc" id="L115">        Type supTyp = superClass.verifyType(compiler);</span>
        
        //Je verifie que la SuperClass est bien un identificateur de classe
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if(!supTyp.isClass())throw new ContextualError(&quot;La super classe que vous avez declarer n'est pas une classe&quot;, getLocation());</span>
        
<span class="fc" id="L120">        superClass.setType(supTyp);</span>

<span class="fc" id="L122">        supTyp = supTyp.asClassType(&quot;shouldnt happen&quot;, getLocation());</span>

        //Je recupere la definition de la superClasse
<span class="fc" id="L125">        ClassDefinition superDef = compiler.environmentType.defOfClass(superClass.getName());</span>

<span class="fc" id="L127">        this.superClass.setDefinition(superDef);</span>


        //On declare notre Class

        //On recupere le nom a partir de l'identifier de la classe
<span class="fc" id="L133">        Symbol className = this.getName().getName();</span>

        //On creer notre Type 
<span class="fc" id="L136">        ClassType classType = new ClassType(className, getLocation(), superDef);</span>

        //On creer notre definition pour la classe
<span class="fc" id="L139">        ClassDefinition cDef = new ClassDefinition(classType, getLocation(), superDef);</span>

        //La methode declaClass fais la verification du nom car dans cette derniere si le nom exite deja dans l'environnement des types il  y'a une erreur Contextuelle leve
<span class="fc" id="L142">        compiler.environmentType.declareClass(className, cDef, getLocation());</span>

<span class="fc" id="L144">        this.name.setDefinition(cDef);</span>



<span class="fc" id="L148">    }</span>


    @Override
    /**
     * Passe 2 Verification du nom des methodes et des champs
    */
    protected void verifyClassMembers(DecacCompiler compiler) throws ContextualError {

        
        //Recuperation des Definitions de la class
<span class="fc" id="L159">        ClassDefinition clsDef = compiler.environmentType.defOfClass(this.getName().getName());</span>

        //On verifie les champs declarés

        //On recupere la liste de champs
<span class="fc" id="L164">        ListDeclField lfield = this.getListDeclField();</span>

        //Creation des EnvExp apartir de la verfication des liste de declaration des champs
<span class="fc" id="L167">        EnvironmentExp envExpF = lfield.verifyListDeclFieldDeuxiemePasse(compiler ,clsDef);</span>

        //On verifie la declaration des methodes 

        //Recuperation de la liste des Champs et Methodes De cls
<span class="fc" id="L172">        ListDeclMethod lmthd = this.getListDeclMethod();</span>

        //Creation de EnvExpM a partir de la verificatio, de la declaration des methodes
<span class="fc" id="L175">        EnvironmentExp envExpM = lmthd.verifyListDeclMethodDeuxiemePasse(compiler, clsDef);</span>

        
        try{
            //Empilement des EnvExp
<span class="fc" id="L180">            clsDef.getMembers().unionDisjoint(envExpM, envExpF);</span>
<span class="fc" id="L181">        }catch(DoubleDefException e){</span>
<span class="fc" id="L182">           throw new ContextualError(&quot;Double Definition of the methode or the field&quot;, getLocation());</span>
        }
<span class="fc bfc" id="L184" title="All 2 branches covered.">        for (AbstractDeclMethod m : listMethod.getList()){</span>
<span class="fc" id="L185">            DeclMethod m1=(DeclMethod)m;</span>
<span class="fc" id="L186">            m1.getMethName().getMethodDefinition().setLabel(new Label(&quot;code.&quot;+name.getName().getName()+&quot;.&quot;+m1.getMethName().getName().getName()));</span>
        }



<span class="fc" id="L191">    }</span>
    
    
    @Override
    /**
     * Passe 3 Verification du corps des methodes 
     */
    protected void verifyClassBody(DecacCompiler compiler) throws ContextualError {

<span class="fc" id="L200">        LOG.debug(&quot;Verifyng the class body of &quot;+ name.getName());</span>

        //On recupere la definition de notre classe
<span class="fc" id="L203">        ClassDefinition clsDef = compiler.environmentType.defOfClass(this.name.getName());</span>

        //Recuperation du EnvExp de cls
<span class="fc" id="L206">        EnvironmentExp currEnv = clsDef.getMembers();</span>

<span class="fc" id="L208">        listField.verifyListDeclFieldTroisiemePasse(compiler, currEnv, clsDef);</span>
        
<span class="fc" id="L210">        listMethod.verifyListDeclMethodTroisiemePasse(compiler, currEnv, clsDef);</span>

<span class="fc" id="L212">    }</span>





    @Override
    protected void prettyPrintChildren(PrintStream s, String prefix) {
        //throw new UnsupportedOperationException(&quot;Not yet supported&quot;);
<span class="fc" id="L221">        name.prettyPrint(s,prefix, false);</span>
<span class="fc" id="L222">        superClass.prettyPrint(s, prefix, false);</span>
<span class="fc" id="L223">        listField.prettyPrint(s, prefix, false);</span>
<span class="fc" id="L224">        listMethod.prettyPrint(s, prefix, true);</span>

<span class="fc" id="L226">    }</span>

    @Override
    protected void iterChildren(TreeFunction f) {
        //throw new UnsupportedOperationException(&quot;Not yet supported&quot;);
<span class="nc" id="L231">        name.iter(f);</span>
<span class="nc" id="L232">        superClass.iter(f);</span>
<span class="nc" id="L233">        listField.iter(f);</span>
<span class="nc" id="L234">        listMethod.iter(f);</span>
<span class="nc" id="L235">    }</span>

    public TreeMap&lt;Integer, MethodDefinition&gt; genlistMethode(DecacCompiler compiler, EnvironmentExp envThisClass, TreeMap&lt;Integer, MethodDefinition&gt; listMethode) {
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if(envThisClass.getParent() != null){</span>
<span class="nc" id="L239">            TreeMap&lt;Integer, MethodDefinition&gt;superMethode=genlistMethode(compiler, envThisClass.getParent(), listMethode);</span>
<span class="nc" id="L240">            listMethode.putAll(superMethode);</span>
        }
<span class="nc bnc" id="L242" title="All 2 branches missed.">        for (Symbol s : envThisClass.getMap().keySet()) {</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">            if(envThisClass.getMap().get(s).isMethod()){</span>
<span class="nc" id="L244">            MethodDefinition m =(MethodDefinition) envThisClass.getMap().get(s);</span>
<span class="nc" id="L245">            listMethode.put(m.getIndex(),m);</span>
            }
        }
<span class="nc" id="L248">        return listMethode;</span>

    }

    @Override
    public void codeGenClass(DecacCompiler compiler){
<span class="nc" id="L254">        compiler.addComment(&quot;code de la table des méthodes de &quot;+name.getName().getName());</span>
        //  adresse de la super classe si cette dernier n'est pas Object , sinon on utilise celle de Object 
<span class="nc bnc" id="L256" title="All 2 branches missed.">        DAddr adresse = (superClass.getClassDefinition().getType().getName().getName()==&quot;Object&quot;)? new RegisterOffset(1,Register.GB):superClass.getClassDefinition().getOperand();</span>
        // load de l'adresse de cette adress dans R0
<span class="nc" id="L258">        compiler.addInstruction(new LEA(adresse, Register.R0));</span>
        // on associe à notre classe  une adresse  GB
<span class="nc" id="L260">        name.getClassDefinition().setOperand(new RegisterOffset(compiler.getHandleMemory().incrementeGB(),Register.GB));</span>
<span class="nc" id="L261">        compiler.addInstruction(new STORE(Register.R0, name.getClassDefinition().getOperand()));</span>
<span class="nc" id="L262">        EnvironmentExp envThisClass =name.getClassDefinition().getMembers();</span>
        // les methodes de la superclasse non redifinie par la classe actuelle ( pour préserver l'ordre )
<span class="nc" id="L264">        TreeMap&lt;Integer, MethodDefinition&gt; listMethode=new TreeMap&lt;Integer, MethodDefinition&gt; ();</span>
<span class="nc" id="L265">        listMethode=genlistMethode(compiler, envThisClass, listMethode);</span>
<span class="nc" id="L266">        Map&lt;Integer, MethodDefinition&gt; sortedMap = listMethode.entrySet().stream().sorted(Map.Entry.comparingByKey()).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1, TreeMap::new));</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">        for (MethodDefinition m : sortedMap.values()){</span>
<span class="nc" id="L268">           compiler.addInstruction(new LOAD(new LabelOperand(m.getLabel()), Register.R0));</span>
<span class="nc" id="L269">           compiler.addInstruction(new STORE(Register.R0,new RegisterOffset(compiler.getHandleMemory().incrementeGB(),Register.GB)));</span>
            
        }

<span class="nc" id="L273">    }</span>
    
    @Override
    public void codeGenInitField(DecacCompiler compiler) {
        //ajouter TSTO
<span class="nc" id="L278">        compiler.addLabel(new Label(&quot;init.&quot;+ name.getName().getName()));</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (superClass.getClassDefinition().getType().getName().getName()!=&quot;Object&quot;){</span>
<span class="nc" id="L280">            compiler.addInstruction(new LOAD(new RegisterOffset(-2, Register.LB), Register.R1));</span>
<span class="nc" id="L281">            compiler.addInstruction(new PUSH(Register.R1));</span>
<span class="nc" id="L282">            compiler.addInstruction(new BSR(new Label(&quot;init.&quot;+superClass.getName().getName())));</span>
<span class="nc" id="L283">            compiler.addInstruction(new SUBSP(new ImmediateInteger(1)));</span>
        }
<span class="nc bnc" id="L285" title="All 2 branches missed.">        for (AbstractDeclField f : listField.getList()){</span>
<span class="nc" id="L286">            f.codeGenDeclField(compiler);</span>
        }
<span class="nc" id="L288">        compiler.addInstruction(new RTS());</span>

<span class="nc" id="L290">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>