<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MethodCall.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Deca Compiler</a> &gt; <a href="index.source.html" class="el_package">fr.ensimag.deca.tree</a> &gt; <span class="el_source">MethodCall.java</span></div><h1>MethodCall.java</h1><pre class="source lang-java linenums">package fr.ensimag.deca.tree;

import fr.ensimag.deca.DecacCompiler;
import fr.ensimag.deca.context.ClassDefinition;
import fr.ensimag.deca.context.ClassType;
import fr.ensimag.deca.context.ContextualError;
import fr.ensimag.deca.context.EnvironmentExp;
import fr.ensimag.deca.context.MethodDefinition;
import fr.ensimag.deca.context.Type;
import fr.ensimag.deca.tools.IndentPrintStream;
import fr.ensimag.ima.pseudocode.ImmediateInteger;
import fr.ensimag.ima.pseudocode.Label;
import fr.ensimag.ima.pseudocode.NullOperand;
import fr.ensimag.ima.pseudocode.Register;
import fr.ensimag.ima.pseudocode.RegisterOffset;
import fr.ensimag.ima.pseudocode.instructions.ADDSP;
import fr.ensimag.ima.pseudocode.instructions.BEQ;
import fr.ensimag.ima.pseudocode.instructions.BRA;
import fr.ensimag.ima.pseudocode.instructions.BSR;
import fr.ensimag.ima.pseudocode.instructions.CMP;
import fr.ensimag.ima.pseudocode.instructions.LOAD;
import fr.ensimag.ima.pseudocode.instructions.STORE;
import fr.ensimag.ima.pseudocode.instructions.SUBSP;

import java.io.PrintStream;
import org.apache.commons.lang.Validate;



public class MethodCall extends AbstractExpr{

    AbstractExpr objet;
    AbstractIdentifier ident;
    ListExpr args;

<span class="fc" id="L36">        public MethodCall(AbstractExpr selectExpr, AbstractIdentifier ident, ListExpr args){</span>
<span class="fc" id="L37">        Validate.notNull(selectExpr, &quot;The select expression shouldnt be null&quot;);</span>
<span class="fc" id="L38">        Validate.notNull(ident, &quot;A methode  shouldeclared&quot;);</span>
<span class="fc" id="L39">        Validate.notNull(args, &quot;The list of arguments shouldnt be null&quot;);</span>
<span class="fc" id="L40">        this.objet = selectExpr;</span>
<span class="fc" id="L41">        this.ident = ident;</span>
<span class="fc" id="L42">        this.args = args;</span>
<span class="fc" id="L43">    }</span>
    
    
   



    @Override
    public Type verifyExpr(DecacCompiler compiler, EnvironmentExp localEnv, ClassDefinition currentClass)
            throws ContextualError {
       
        //On doit verifier l'objet qui appel la method
<span class="fc" id="L55">        ClassType typeClass2 = this.objet.verifyExpr(compiler, localEnv, currentClass).asClassType(&quot;Isnt a class Type&quot;, getLocation());</span>

<span class="fc" id="L57">        EnvironmentExp envExp2 = compiler.environmentType.defOfClass(typeClass2.getName()).getMembers();</span>

<span class="pc bpc" id="L59" title="1 of 2 branches missed.">        if(envExp2.get(this.ident.getName()) == null)throw  new ContextualError(&quot;There is no such method&quot;, getLocation());</span>

<span class="fc" id="L61">        MethodDefinition defMeth = envExp2.get(this.ident.getName()).asMethodDefinition(&quot;Isnt a method&quot;, getLocation());</span>

<span class="pc bpc" id="L63" title="1 of 2 branches missed.">        if(defMeth == null)throw new ContextualError(&quot;the field is unkown&quot;, getLocation());</span>

<span class="fc" id="L65">        this.ident.setDefinition(defMeth);</span>

<span class="fc" id="L67">        Type methType = defMeth.getType();</span>

<span class="fc" id="L69">        this.ident.setType(methType);</span>

<span class="pc bpc" id="L71" title="1 of 2 branches missed.">        if(this.args.size() != defMeth.getSignature().size())throw new ContextualError(&quot;Wrong number of parameters&quot;, getLocation());</span>

<span class="fc" id="L73">        int index = 0;</span>
        //on verifie la liste d'arguments
<span class="fc bfc" id="L75" title="All 2 branches covered.">        for(AbstractExpr arg : this.args.getList()){</span>
<span class="fc" id="L76">            arg = arg.verifyRValue(compiler, localEnv, currentClass, defMeth.getSignature().paramNumber(index));</span>
<span class="fc" id="L77">            index++;</span>
        }

<span class="fc" id="L80">        this.setType(methType);</span>

        //On doit retourner le type de retour de la methode
<span class="fc" id="L83">        return ident.getType();</span>
    }

    @Override
    public void decompile(IndentPrintStream s) {
<span class="nc" id="L88">        this.objet.decompile(s);</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">        if(!(objet instanceof ThisLiteral))s.print(&quot;.&quot;);</span>
<span class="nc" id="L90">        this.ident.decompile(s);</span>
<span class="nc" id="L91">        s.print(&quot;(&quot;);</span>
<span class="nc" id="L92">        this.args.decompile(s);</span>
<span class="nc" id="L93">        s.print(&quot;)&quot;);</span>
<span class="nc" id="L94">    }</span>

    @Override
    protected void prettyPrintChildren(PrintStream s, String prefix) {
        // TODO Auto-generated method stub
        //throw new UnsupportedOperationException(&quot;Unimplemented method 'prettyPrintChildren'&quot;);
<span class="fc" id="L100">        objet.prettyPrint(s, prefix, false);</span>
<span class="fc" id="L101">        ident.prettyPrint(s, prefix, false);</span>
<span class="fc" id="L102">        args.prettyPrint(s, prefix, true);</span>
<span class="fc" id="L103">    }</span>

    @Override
    protected void iterChildren(TreeFunction f) {
        // TODO Auto-generated method stub
        //throw new UnsupportedOperationException(&quot;Unimplemented method 'iterChildren'&quot;);
<span class="nc" id="L109">        objet.iter(f);</span>
<span class="nc" id="L110">        ident.iter(f);</span>
<span class="nc" id="L111">        args.iter(f);</span>
<span class="nc" id="L112">    }</span>

    @Override
    public void codeGenInst(DecacCompiler compiler) {  
         //On réserve de la place pour les  paramètres
<span class="nc" id="L117">        compiler.addInstruction(new ADDSP(args.getList().size()+1)); </span>
    
<span class="nc" id="L119">        objet.codeGenInst(compiler) ;     // On continuera à se diriger vers la gauche jusqu'à trouver un identifier ou bien THIS</span>
             
<span class="nc" id="L121">        compiler.addInstruction(new STORE(Register.getR(compiler.getHandleMemory().getfull()), new RegisterOffset(0, Register.SP)));</span>

       
<span class="nc" id="L124">        int indexparam = -1;</span>

<span class="nc bnc" id="L126" title="All 2 branches missed.">        for ( AbstractExpr E : args.getList()){</span>
            // je met ensuite chaque paramètre dans l'adress du declParam dans la declMethode
<span class="nc" id="L128">            E.codeGenInst(compiler); // E est ensuite storé dans le dernier registre dispo</span>
<span class="nc" id="L129">            compiler.addInstruction(new STORE(Register.getR(compiler.getHandleMemory().getfull()),new RegisterOffset(indexparam, Register.SP)));</span>
<span class="nc" id="L130">            compiler.getHandleMemory().registerLiberate();</span>
<span class="nc" id="L131">            indexparam--; </span>
        }
        // une fois on a mis l'objet dans sa place et les arguments aussi , on saute vers le label de la methode 
<span class="nc" id="L134">        compiler.addInstruction(new LOAD(new RegisterOffset(0, Register.SP) , Register.getR(compiler.getHandleMemory().getfull())));</span>
<span class="nc" id="L135">        compiler.addInstruction(new CMP(new NullOperand() , Register.getR(compiler.getHandleMemory().getfull()) ));</span>
<span class="nc" id="L136">        compiler.addInstruction(new BEQ(compiler.getDn()));</span>

<span class="nc" id="L138">        compiler.addInstruction(new LOAD(new RegisterOffset(0,  Register.getR(compiler.getHandleMemory().getfull())),  Register.getR(compiler.getHandleMemory().getfull())));</span>
<span class="nc" id="L139">        compiler.addInstruction(new BSR(new RegisterOffset( ident.getMethodDefinition().getIndex(), Register.getR(compiler.getHandleMemory().getfull()))));</span>
<span class="nc" id="L140">        compiler.addInstruction(new SUBSP(new ImmediateInteger(args.getList().size()+1)));</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">        if(ident.getType().isVoid()){</span>
<span class="nc" id="L142">        compiler.getHandleMemory().registerLiberate();</span>
        }

<span class="nc" id="L145">    }</span>

    @Override
    protected void codeGenPrint(DecacCompiler compiler) {
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if(ident.getType().isVoid()){</span>
<span class="nc" id="L150">            throw new IllegalArgumentException(&quot;This method's type of return is void !!&quot;);</span>
            // à reverifier le cas de mthode de retour void 
        }else{
<span class="nc" id="L153">            this.codeGenInst(compiler);</span>
<span class="nc" id="L154">            compiler.addInstruction(new LOAD(Register.R0, Register.R1));</span>
<span class="nc" id="L155">            ident.getDefinition().getType().codeGenPrint(compiler);</span>
        }
<span class="nc" id="L157">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>